CacheLine Level Problems:
        1. true-sharing:
        2. false-sharing:

How to determine if it is a true sharing or false sharing:
        false-sharing: if only one thread access the words belong to this object in this cache line,
but with a high access latency number in thie cache line.

CacheLine Level Solutions:
        1. true-sharing: reduce sharing between threads, reduce write operation.
        2. false-sharing:
                        a. can be fixed by some allocators.
                        b. align up memory size of false sharing objects.

CacheLine Level Hints needed:
        1. true-sharing: access threads id, (access number from each thread, access call site)
        2. false-sharing: may only report it is a false sharing





Page Level Problems:
        1. true-sharing;
        2. false-sharing: caused by allocators;

How to determine if it is a true sharing or false sharing:
        false-sharing: if only one thread access the words belong to this object in this page,
but with a high access latency number in this page.

Page Level Solutions:
        1. true-sharing: reduce sharing between threads, or use some allocator to do interleaved allocation,
                         try to relocate the page to the most accessing thread.
        2. false-sharing: use numa-allocators

Page Level Hints needed:
        1. true-sharing: first touch thread id, access number from non-first-touch-thread and first-touch-thread, (access call site)
        2. false-sharing: may only report it is a false sharing



How to define how serious it is about numa issue? ---- invalidation number, so in the cache line level is enough.
But in the page level, we more focus on access number, why?

----The difference between cache line and page is that the solution of true sharing is little different. In the cache line, we more
focus on the cache hit rate in all cores, which is related to invalidation numbers here.So the solution includes reduce modifing
the value, reduce copies(sharing) in cores.
But in the page level, we more focus on which node the page is located, which also means we prefer to make the page closer to the
most accessing thread, and reduce the access number from remote node. So the solution is to reduce access number from other threads,
and make the page local with the main accessing thread.So I think we also concern why this page is located here (also means which
object first touch this page.)



In my previous design:
    I also use the invalidation number to determine if it is false sharing or true sharing, so I need the invalidation number in word
level------according the DiagnosedInfo. In this case, I always think about whether there are true sharing problems for this object
if self, even in cache lines or pages occupied by multiple objects. But this one may can not differentiate it in the cache line level.
In the page level, it may tells something valuable to people from another angle.
In the another thinking, I determine it as false sharing as long as the there are single thread accesses, which is easier and more efficient I guess.
        DiagnosedInfo {
                ObjectInfoPointer;
                totalInvalidateNumberCauseedByThisObject;   // in overall level, tell people how bad this object is about numa issues.
                // in cache line level:
                invalidateNumberFromTotalCoverdCacheLines;   // in cache line level, issues caused by application it self.
                invalidateNumberFromPartialCoverdCacheLines;  // in cache line level, issues may caused by allocators.
                invalidateNumberFromThisObjectInPartialCoverdCacheLines;
                // in page level:
                invalidateNumberFromTotalCoverdPages;    // in page line level, issues caused by application it self.
                invalidateNumberFromThisObjectInPartialCoverdPages;   // in page line level, issues may caused by allocators.
                invalidateNumberFromThisObjectInPartialCoverdPagesWhenThePageFirstTouchedFromThisObject;
        }
