Basic Data Structure:

        ObjectInfo {
            startAddress;
            size;
            callSite;
        }

        PageAccessInfo{
            firstTouchThreadId;
            firstTouchAddress;
            ifTotalCoveredBySingleObject;
            structure {
                writingNumber;
                detailedCacheLineInfoPointer;
                totalInvalidateNumberCausedByThisWordFirstTouched;
            }CacheLineAccessInfo[CACHE_LINE_NUMBER]
        }

        CacheLineDetailedAccessInfo {
            lastWriteThreadId;
            followingAccessThreadIdBitMask;
            invalidateNumber[NumberOfWordsInCacheLine]
        }   //focus on the number of cache line invalidation

        DiagnosedInfo {
            ObjectInfoPointer;
            totalInvalidateNumberCauseedByThisObject;   // in overall level, tell people how bad this object is about numa issues.
            // in cache line level:
            invalidateNumberFromTotalCoverdCacheLines;   // in cache line level, issues caused by application it self.
            invalidateNumberFromPartialCoverdCacheLines;  // in cache line level, issues may caused by allocators.
            invalidateNumberFromThisObjectInPartialCoverdCacheLines;
            // in page level:
            invalidateNumberFromTotalCoverdPages;    // in page line level, issues caused by application it self.
            invalidateNumberFromThisObjectInPartialCoverdPages;   // in page line level, issues may caused by allocators.
            invalidateNumberFromThisObjectInPartialCoverdPagesWhenThePageFirstTouchedFromThisObject;
        }


Global Variable:

        HashMap<ObjectInfo> objectInfoMapping; (because they are only accessed in the malloc and free function)

        HashMap<> diagnosedInfoMapping; (key:callSite, only accessed in the free function)

        ShadowMapping<PageAccessInfo> accessMapping:(shadow mapping: mmap a big chunk of memory form the first beginning)

                                    (accessMapping<PageAccessInfo>)
        ----------------------------------------------------------------------------------------------------------------------------
        |           |           |      (cache line base info)       |                                                               |
        | first     |   .....   |   writing number;                 |             .......                                           |
        | Touch     |           |   detailed info pointer;          |                                                               |
        | ThreadId  |           |  totalInvalidateNumberCausedBy    |                                                               |
        |           |           |   ThisWordFirstTouched;           |
        ---------------------------------------------------------------------------------------------------------------------------
                                                  |
                                                  |  if writingNumber > threshold
                                                  |
                                                 \|/   (memories are from self-managed allocations to speed up this process
                    (CacheLineDetailedAccessInfo)       and also reduce memory overheads)
                 --------------------------------------------------------------------------
                 | lastWriteThreadId |             |    (word base info)     |            |
                 |  followingAccess  |    ....     |   invalidateNumber      |  ....      |
                 |   ThreadBitMask   |             |                         |            |
                 |-------------------------------------------------------------------------



Processing flowï¼š

        malloc(){
            1. insert ObjectInfo into objectInfoMapping hashMap.   (very low overeheads)
            2. set ifTotalCoveredBySingleObject in PageAccessInfo;
            3. return the allocated address.
        }

        handleAccess(){
            1. increase the write number in the corresponding cache line slot.  (very low overeheads)
            2. if the write number > certain threshold                          (very low overeheads)
                      a. allocated CacheLineDetailedAccessInfo
                      b. if writing access:                  (may cause 2-3 cache line miss)
                            1. set lastWriteThreadId
                            2. followingAccessThreadBitMask = 1 << lastWriteThreadId (which means invalidate cache lines for other threads)
                            3. update invalidateNumber() in the word level;
                            4. if not TotalCoveredBySingleObject
                                    update invalidateNumber() in totalInvalidateNumberCausedByThisWordFirstTouched;
                      c. if reading access:                   (may cause 2-3 cache line miss)
                            1. if followingAccessThreadBitMask & (1 << threadId) ==0: (which means first time access for this thread)
                                    a.followingAccessThreadBitMask = (followingAccessThreadBitMask & (1 << threadId))
                                    b.update invalidateNumber() in the word level;
                                    c.update invalidateNumber() in totalInvalidateNumberFirstTouched;
                                    d.if not TotalCoveredBySingleObject
                                            update invalidateNumber() in totalInvalidateNumberCausedByThisWordFirstTouched;
        }

        update invalidateNumber(){
            if currentThreadId == pageFirstTouchThreadId:
                    invalidateNumber++;    (local node access)
            else:
                    invalidateNumber+=1.5;  (remote node access)
        }

        sigsegv handler() {
            update the first touch thread id and the first touch address;
        }

        // data structure for the final results. how to collect the page level info....
        free() {
        1. get ObjectInfo from the hashMap-objectInfoMapping. (very low overeheads)
        2. collect DiagnosedInfo data from the accessMapping. (can be easily summed up according to current data)
        3. store the diagnose results to the diagnosedInfoMapping.
        4. remove object from the hashMap-objectInfoMapping.
        5. free the object.
        }
