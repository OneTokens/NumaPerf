Basic Data Structure:

        ObjectInfo {
            startAddress;
            size;
            callSite;
        }

        BasicPageAccessInfo{
%            firstTouchThreadId;
            partialOccupiedCacheLineBitMask;
            cacheLineWritingNumber[CACHE_LINE_NUMBER];
        }

        PageDetailedAccessInfo{
            CacheLineDetailedAccessInfo[CACHE_LINE_NUMBER]
        }

        CacheLineDetailedAccessInfo {
            totalCopyNumber;
            totalAccessThreadBitMask; or copyNumber[ThreadNumber]
            accessThreadBitMaskAfterWriting;
            wordDetailedAccessInfoPointer;   // only allocate this info if this cache line is partially occupied.
        }

        wordDetailedAccessInfo {
            totalAccessThreadBitMask[WORDS_NUMBER];
        }

        DiagnosedInfo {
            totalCopyNumber;
            totalAccessThreadBitMask; or copyNumber[ThreadNumber];
            totalCopyNumberInFalseSharingPages;
            totalCopyNumberInFalseSharingCacheLines;
        }


Global Variable:

        HashMap<ObjectInfo> objectInfoMapping; (because they are only accessed in the malloc and free function)

        HashMap<> diagnosedInfoMapping; (key:callSite, only accessed in the free function)

        ShadowMapping<BasicPageAccessInfo> basicAccessMapping;

        ShadowMapping<PageDetailedAccessInfo> detailsAccessMapping:(shadow mapping: mmap a big chunk of memory form the first beginning)


Processing flowï¼š

        malloc(){
            1. insert ObjectInfo into objectInfoMapping hashMap.   (very low overeheads)
            2. set ifTotalCoveredBySingleObject in PageAccessInfo;
            3. return the allocated address.
        }

        handleAccess(){
            1. increase the write number in the corresponding cache line slot.  (very low overeheads)
            2. if the write number > certain threshold                          (very low overeheads)
                      a. if this cache line is marked as partially occupied cache line:
                            allocate wordDetailedAccessInfo for it.
                      b. if writing access:                  (may cause 2-3 cache line miss)
                            1. accessThreadBitMaskAfterWriting = 1 << lastWriteThreadId (which means invalidate cache lines for other threads)
                            2. update totalCopyNumber in the cache level;
                            3. update totalAccessThreadBitMask in cache level
                            4. if marked as partially occupied cache line
                                    update totalAccessThreadBitMask in word level.
                      c. if reading access:                   (may cause 2-3 cache line miss)
                            1. if followingAccessThreadBitMask & (1 << threadId) ==0: (which means first time access for this thread)
                                    a. update accessThreadBitMaskAfterWriting
                                    b. if marked as partially occupied cache line
                                            update totalAccessThreadBitMask in word level.
        }

%        update invalidateNumber(){
%            if currentThreadId == pageFirstTouchThreadId:
%                    invalidateNumber++;    (local node access)
%            else:
%                    invalidateNumber+=1.5;  (remote node access)
%        }

        sigsegv handler() {
            update the first touch thread id and the first touch address;
        }

        // data structure for the final results. how to collect the page level info....
        free() {
            1. get ObjectInfo from the hashMap-objectInfoMapping. (very low overeheads)
            2. collect DiagnosedInfo data from the accessMapping. (can be easily summed up according to current data)
            3. store the diagnose results to the diagnosedInfoMapping.
            4. remove object from the hashMap-objectInfoMapping.
            5. free the object.
        }
